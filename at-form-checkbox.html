<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../at-core-theme/at-core-theme.html" />
<link rel="stylesheet" href="at-form-checkbox.css" />

<dom-module id="at-form-checkbox-semantic">
  <template>
    <at-core-theme></at-core-theme>
    <div id="uiCheckbox" class="ui checkbox">
      <input id="input" type="checkbox" name="{{name}}">
      <label>{{label}}</label>
    </div>
  </template>
</dom-module>

<script>
  "use strict";
  Polymer({
    is: "at-form-checkbox-semantic",
    properties: {
      name: {
        type: String,
        value: ''
      },
      label: {
        type: String,
        value: ''
      },
      disabled: {
        type: Boolean,
        value: false
      },
      toggle: {
        type: Boolean,
        value: false
      },
      slider: {
        type: Boolean,
        value: false
      },
      value: {
        type: String,
        value: "false",
      }
    },
    valueChanged: function (newValue, oldValue) {
      if (this.value === "true") {
        this.$.input.setAttribute('checked', '');
      } else if (this.value === "false") {
        this.$.input.removeAttribute('checked');
      }

      this.fire('change', this.value);
    },
    ready: function () {
      // set disabled class if element is disabled
      if (this.disabled) {
        this.$.uiCheckbox.classList.add('disabled');
      }
      if (this.toggle) {
        this.$.uiCheckbox.classList.add('toggle');
      }
      if (this.slider) {
        this.$.uiCheckbox.classList.add('slider');
      }

      this.valueChanged('', '');

      var settings = {
        namespace: 'checkbox' + (new Date()).getTime(),
        onChecked: function () {
          this.value = "true";
        },
        onUnchecked: function () {
          this.value = "false";
        }
      };
      var instance = window.atFormCheckbox.apply(this.$.uiCheckbox, [settings]);
      //      debugger;
    }
  });

  (function (dataInterface) {
    var _data = {};
    dataInterface.setData = function (key, value) {
      if (key !== undefined) {
        _data[key] = value;
      }
    };
    dataInterface.getData = function (key) {
      if (key !== undefined) {
        return _data[key];
      }
    };
    dataInterface.removeData = function (key) {
      if (key !== undefined) {
        delete _data[key];
      }
    };
  })(window.atFormData = window.atFormData || {});

  (function (window, document, dataInterface, undefined) {
    "use strict";

    window.atFormCheckbox = function (parameters) {
      var
        moduleSelector = '', // moduleSelector is used in display method to display title; TODO maybe become parameter

        time = new Date().getTime(), // current time
        performance = [],

        query = arguments[0],
        methodInvoked = (typeof query == 'string'),
        queryArguments = [].slice.call(arguments, 1),
        returnedValue;

      var
        settings = window.atFormCheckbox.extend(true, {}, window.atFormCheckbox.settings, parameters),

        className = settings.className,
        namespace = settings.namespace,
        selector = settings.selector,
        error = settings.error,

        eventNamespace = '.' + namespace,
        moduleNamespace = 'module-' + namespace,

        $module = this,
        //        $module = $(this),
        $label = this.querySelector(selector.label),
        //        $label = $(this).find(selector.label).first(),
        $input = this.querySelector(selector.input),
        //        $input = $(this).find(selector.input),

        instance = dataInterface.getData(moduleNamespace),

        observer,
        element = this,
        module;

      module = {

        initialize: function () {
          // in this function this is the same as module
          module.verbose('Initializing checkbox', settings);

          // we do not need to create a label becase we always have label
          //          module.create.label();
          module.add.events();

          if (module.is.checked()) {
            module.set.checked();
            if (settings.fireOnInit) {
              settings.onChecked.call($input);
              //              settings.onChecked.call($input.get());
            }
          } else {
            module.remove.checked();
            if (settings.fireOnInit) {
              settings.onUnchecked.call($input);
              //              settings.onUnchecked.call($input.get());
            }
          }
          module.observeChanges();

          module.instantiate();
        },

        instantiate: function () {
          module.verbose('Storing instance of module', module);
          instance = module;
          dataInterface.setData(moduleNamespace, module);
        },

        destroy: function () {
          module.verbose('Destroying module');
          module.remove.events();
          dataInterface.removeData(moduleNamespace);
        },

        refresh: function () {
          // this here is module instance; we need this to be the html element
          $module = element;
          //          $module = $(this);
          $label = element.querySelector(selector.label);
          //          $label = $(this).find(selector.label).first();
          $input = element.querySelector(selector.input);
          //          $input = $(this).find(selector.input);
        },

        observeChanges: function () {
          if ('MutationObserver' in window) {
            observer = new MutationObserver(function (mutations) {
              module.debug('DOM tree modified, updating selector cache');
              module.refresh();
            });
            observer.observe(element, {
              childList: true,
              subtree: true
            });
            module.debug('Setting up mutation observer', observer);
          }
        },

        attachEvents: function (selector, event) {
          var
            $element = $(selector);
          event = $.isFunction(module[event]) ? module[event] : module.toggle;
          if ($element.length > 0) {
            module.debug('Attaching checkbox events to element', selector, event);
            $element
              .on('click' + eventNamespace, event);
          } else {
            module.error(error.notFound);
          }
        },

        event: {
          keydown: function (event) {
            var
              key = event.which,
              keyCode = {
                enter: 13,
                space: 32,
                escape: 27
              };
            if (key == keyCode.escape) {
              module.verbose('Escape key pressed blurring field');
              var blurEvent = document.createEvent('HTMLEvents');
              blurEvent.initEvent('blur', false, false);
              $module.dispatchEvent(blurEvent);
              //              $module
              //                .blur();
            }
            if (!event.ctrlKey && (key == keyCode.enter || key == keyCode.space)) {
              module.verbose('Enter key pressed, toggling checkbox');
              module.toggle.call(this);
              event.preventDefault();
            }
          }
        },

        is: {
          radio: function () {
            return $module.classList.contains(className.radio);
            //            return $module.hasClass(className.radio);
          },
          checked: function () {
            var checkedAttr = $input.getAttribute('checked');
            return (checkedAttr !== null || checkedAttr !== '') && checkedAttr;
            //            return $input.prop('checked') !== undefined && $input.prop('checked');
          },
          unchecked: function () {
            return !module.is.checked();
          }
        },

        can: {
          change: function () {
            var hasDisabled = $module.classList.contains(className.disabled);
            var hasReadonly = $module.classList.contains(className.readOnly);
            var hasPropDisabled = $input.getAttribute('disabled');
            return !(hasDisabled || hasReadonly || hasPropDisabled);
            //            return !($module.hasClass(className.disabled) || $module.hasClass(className.readOnly) || $input.prop('disabled'));
          },
          uncheck: function () {
            return (typeof settings.uncheckable === 'boolean') ? settings.uncheckable : !module.is.radio();
          }
        },

        set: {
          checked: function () {
            $module.classList.add(className.checked);
            //            $module.addClass(className.checked);
          },
          tab: function () {
            if ($input.getAttribute('tabindex') === undefined) {
              $input.setAttribute('tabindex', 0);
            }

            //            if ($input.attr('tabindex') === undefined) {
            //              $input
            //                .attr('tabindex', 0);
            //            }
          }
        },

        create: {
          // this function is not needed since component will always have label
          label: function () {
            // if there is a label element above $input
            if ($input.prevAll(selector.label).length > 0) {
              // detach label from the html tree and insert it after $input
              $input.prev(selector.label).detach().insertAfter($input);
              module.debug('Moving existing label', $label);
            } else if (!module.has.label()) {
              // if label doesn't exist, create one and insert it after $input
              $label = $('<label>').insertAfter($input);
              module.debug('Creating label', $label);
            }
          }
        },

        has: {
          label: function () {
            return ($label.length > 0);
          }
        },

        add: {
          events: function () {
            module.verbose('Attaching checkbox events');
            $module.addEventListener('click', module.toggle);
            $input.addEventListener('keydown', module.event.keydown);
            //            $module
            //              .on('click' + eventNamespace, module.toggle)
            //              .on('keydown' + eventNamespace, selector.input, module.event.keydown);            
          }
        },

        remove: {
          checked: function () {
            $module.classList.remove(className.checked);
            //            $module.removeClass(className.checked);
          },
          events: function () {
            module.debug('Removing events');
            $module.removeEventListener('click', module.toggle);
            //            $module
            //              .off(eventNamespace);
            dataInterface.removeData(moduleNamespace);
            $input.removeEventListener('keydown', module.event.keydown);
            //            $input
            //              .off(eventNamespace, module.event.keydown);
            // I checked through the code and didn't find a place where events are attached to the label
            // so there is no need to detach events from it
            //            $label
            //              .off(eventNamespace);
          }
        },

        enable: function () {
          module.debug('Enabling checkbox functionality');
          $module.classList.remove(className.disabled);
          //          $module.removeClass(className.disabled);
          $input.prop('disabled', false);
          settings.onEnabled.call($input.get());
        },

        disable: function () {
          module.debug('Disabling checkbox functionality');
          $module.classList.add(className.disabled);
          //          $module.addClass(className.disabled);
          $input.prop('disabled', 'disabled');
          settings.onDisabled.call($input.get());
        },

        check: function () {
          module.debug('Enabling checkbox', $input);
          //          $input
          //            .prop('checked', true)
          //            .trigger('change');
          $input.setAttribute('checked', true);
          var changeEvent = document.createEvent('HtmlEvents');
          changeEvent.initEvent('change', true, true);
          $input.dispatchEvent(changeEvent);

          module.set.checked();
          //          $input.trigger('blur');
          var blurEvent = document.createEvent('HtmlEvents');
          blurEvent.initEvent('blur', false, false);
          $input.dispatchEvent(blurEvent);

          settings.onChange.call($input);
          settings.onChecked.call($input);
          //          settings.onChange.call($input.get());
          //          settings.onChecked.call($input.get());
        },

        uncheck: function () {
          module.debug('Disabling checkbox');
          //          $input
          //            .prop('checked', false)
          //            .trigger('change');
          $input.removeAttribute('checked');
          var changeEvent = document.createEvent('HtmlEvents');
          changeEvent.initEvent('change', true, true);
          $input.dispatchEvent(changeEvent);

          module.remove.checked();
          //          $input.trigger('blur');
          var blurEvent = document.createEvent('HtmlEvents');
          blurEvent.initEvent('blur', false, false);
          $input.dispatchEvent(blurEvent);

          settings.onChange.call($input);
          settings.onUnchecked.call($input);
          //          settings.onChange.call($input.get());
          //          settings.onUnchecked.call($input.get());
        },

        toggle: function (event) {
          if (!module.can.change()) {
            console.log(module.can.change());
            module.debug('Checkbox is read-only or disabled, ignoring toggle');
            return;
          }
          module.verbose('Determining new checkbox state');
          if (module.is.unchecked()) {
            module.check();
          } else if (module.is.checked() && module.can.uncheck()) {
            module.uncheck();
          }
        },
        setting: function (name, value) {
          module.debug('Changing setting', name, value);
          if ($.isPlainObject(name)) {
            $.extend(true, settings, name);
          } else if (value !== undefined) {
            settings[name] = value;
          } else {
            return settings[name];
          }
        },
        internal: function (name, value) {
          if ($.isPlainObject(name)) {
            $.extend(true, module, name);
          } else if (value !== undefined) {
            module[name] = value;
          } else {
            return module[name];
          }
        },
        debug: function () {
          if (settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');
              module.debug.apply(console, arguments);
            }
          }
        },
        verbose: function () {
          if (settings.verbose && settings.debug) {
            if (settings.performance) {
              module.performance.log(arguments);
            } else {
              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');
              module.verbose.apply(console, arguments);
            }
          }
        },
        error: function () {
          module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');
          module.error.apply(console, arguments);
        },
        performance: {
          log: function (message) {
            var
              currentTime,
              executionTime,
              previousTime;
            if (settings.performance) {
              currentTime = new Date().getTime();
              previousTime = time || currentTime;
              executionTime = currentTime - previousTime;
              time = currentTime;
              performance.push({
                'Name': message[0],
                'Arguments': [].slice.call(message, 1) || '',
                'Element': element,
                'Execution Time': executionTime
              });
            }
            clearTimeout(module.performance.timer);
            module.performance.timer = setTimeout(module.performance.display, 100);
          },
          display: function () {
            var
              title = settings.name + ':',
              totalTime = 0;
            time = false;
            clearTimeout(module.performance.timer);
            $.each(performance, function (index, data) {
              totalTime += data['Execution Time'];
            });
            title += ' ' + totalTime + 'ms';
            if (moduleSelector) {
              title += ' \'' + moduleSelector + '\'';
            }
            if ((console.group !== undefined || console.table !== undefined) && performance.length > 0) {
              console.groupCollapsed(title);
              if (console.table) {
                console.table(performance);
              } else {
                $.each(performance, function (index, data) {
                  console.log(data['Name'] + ': ' + data['Execution Time'] + 'ms');
                });
              }
              console.groupEnd();
            }
            performance = [];
          }
        },
        invoke: function (query, passedArguments, context) {
          var
            object = instance,
            maxDepth,
            found,
            response,
            index;
          passedArguments = passedArguments || queryArguments;
          context = element || context;
          if (typeof query == 'string' && object !== undefined) {
            query = query.split(/[\. ]/);
            maxDepth = query.length - 1;
            for (index = 0; index < query.length; index++) {
              (function (depth, value) {
                var camelCaseValue = (depth != maxDepth) ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1) : query;
                if (window.atFormCheckbox.isPlainObject(object[camelCaseValue]) && (depth != maxDepth)) {
                  object = object[camelCaseValue];
                } else if (object[camelCaseValue] !== undefined) {
                  found = object[camelCaseValue];
                  return false;
                } else if (window.atFormCheckbox.isPlainObject(object[value]) && (depth != maxDepth)) {
                  object = object[value];
                } else if (object[value] !== undefined) {
                  found = object[value];
                  return false;
                } else {
                  module.error(error.method, query);
                  return false;
                }
              })(index, query[index]);
            }

            //            $.each(query, function (depth, value) {
            //              var camelCaseValue = (depth != maxDepth) ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1) : query;
            //              if ($.isPlainObject(object[camelCaseValue]) && (depth != maxDepth)) {
            //                object = object[camelCaseValue];
            //              } else if (object[camelCaseValue] !== undefined) {
            //                found = object[camelCaseValue];
            //                return false;
            //              } else if ($.isPlainObject(object[value]) && (depth != maxDepth)) {
            //                object = object[value];
            //              } else if (object[value] !== undefined) {
            //                found = object[value];
            //                return false;
            //              } else {
            //                module.error(error.method, query);
            //                return false;
            //              }
            //            });
          }
          if (window.atFormCheckbox.isFunction(found)) {
            response = found.apply(context, passedArguments);
          } else if (found !== undefined) {
            response = found;
          }
          if (window.atFormCheckbox.isArray(returnedValue)) {
            returnedValue.push(response);
          } else if (returnedValue !== undefined) {
            returnedValue = [returnedValue, response];
          } else if (response !== undefined) {
            returnedValue = response;
          }
          return found;
        }
      };

      // this is where checkbox is finally initialized
      if (methodInvoked) {
        if (instance === undefined) {
          module.initialize();
        }
        module.invoke(query);
      } else {
        if (instance !== undefined) {
          instance.invoke('destroy');
        }
        module.initialize();
      }

      // end of the function
      return (returnedValue !== undefined) ? returnedValue : this;
    }

    // default settings for semantic checkbox
    window.atFormCheckbox.settings = {
      name: 'Checkbox',
      namespace: 'checkbox',

      debug: false,
      verbose: true,
      performance: true,

      // delegated event context
      uncheckable: 'auto',
      fireOnInit: true,

      onChange: function () {},
      onChecked: function () {},
      onUnchecked: function () {},
      onEnabled: function () {},
      onDisabled: function () {},

      className: {
        checked: 'checked',
        disabled: 'disabled',
        radio: 'radio',
        readOnly: 'read-only'
      },

      error: {
        method: 'The method you called is not defined'
      },

      selector: {
        input: 'input[type="checkbox"], input[type="radio"]',
        label: 'label'
      }

    };

    var class2type = {
      "[object Boolean]": "boolean",
      "[object Number]": "number",
      "[object String]": "string",
      "[object Function]": "function",
      "[object Array]": "array",
      "[object Date]": "date",
      "[object RegExp]": "regexp",
      "[object Object]": "object",
      "[object Error]": "error",
    };

    var hasOwn = class2type.hasOwnProperty;

    window.atFormCheckbox.type = function (obj) {
      if (obj == null) {
        return obj + "";
      }
      // Support: Android<4.0, iOS<6 (functionish RegExp)
      return typeof obj === "object" || typeof obj === "function" ?
        class2type[toString.call(obj)] || "object" :
        typeof obj;
    };

    window.atFormCheckbox.isArray = function (obj) {
      return window.atFormCheckbox.type(obj) == Array.isArray;
    };

    window.atFormCheckbox.isWindow = function (obj) {
      return obj != null && obj === obj.window;
    };

    window.atFormCheckbox.isPlainObject = function (obj) {
      // Not plain objects:
      // - Any object or value whose internal [[Class]] property is not "[object Object]"
      // - DOM nodes
      // - window
      if (window.atFormCheckbox.type(obj) !== "object" || obj.nodeType || window.atFormCheckbox.isWindow(obj)) {
        return false;
      }

      if (obj.constructor &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }

      // If the function hasn't returned already, we're confident that
      // |obj| is a plain object, created by {} or constructed with new Object
      return true;
    };

    window.atFormCheckbox.isFunction = function (obj) {
      return window.atFormCheckbox.type(obj) === "function";
    };

    // copy paste and rework of jQuery.extend function; I put it in atFormCheckbox namespace
    // use the same way as jQuery.extend
    window.atFormCheckbox.extend = function () {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if (typeof target === "boolean") {
        deep = target;

        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if (typeof target !== "object" && !window.atFormCheckbox.isFunction(target)) {
        target = {};
      }

      // Extend jQuery itself if only one argument is passed
      if (i === length) {
        target = this;
        i--;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name];

            // Prevent never-ending loop
            if (target === copy) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if (deep && copy && (window.atFormCheckbox.isPlainObject(copy) || (copyIsArray = window.atFormCheckbox.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && window.atFormCheckbox.isArray(src) ? src : [];

              } else {
                clone = src && window.atFormCheckbox.isPlainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[name] = window.atFormCheckbox.extend(deep, clone, copy);

              // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    };

  })(window, document, window.atFormData, undefined);
</script>