<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../at-core-theme/at-core-theme.html" />

<dom-module id="at-form-checkbox">
  <template>
    <at-core-theme></at-core-theme>
    <div id="uiCheckbox" class="ui checkbox">
      <input id="input" type="checkbox" name="{{name}}">
      <label id="label">{{label}}</label>
    </div>
  </template>
</dom-module>

<script>
  "use strict";
  Polymer({
    is: "at-form-checkbox",
    properties: {
      name: {
        type: String,
        value: ''
      },
      label: {
        type: String,
        value: ''
      },
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true,
        observer: 'disabledChanged'
      },
      toggle: {
        type: Boolean,
        value: false,
        observer: 'toggleChanged'
      },
      slider: {
        type: Boolean,
        value: false,
        observer: 'sliderChanged'
      },
      value: {
        type: Object,
        value: false,
        notify: true,
        observer: 'valueChanged'
      }
    },
    _moduleInstance: undefined,
    _scopeCssViaAttr: true,
    valueChanged: function(newValue, oldValue) {
      if (this.value) {
        if (this._moduleInstance !== undefined) {
          this._moduleInstance.check();
        }
      } else if (!this.value) {
        if (this._moduleInstance !== undefined) {
          this._moduleInstance.uncheck();
        }
      }
    },
    disabledChanged: function(newValue, oldValue) {
      if (this.disabled) {
        if (this._moduleInstance !== undefined) {
          this._moduleInstance.disable();
        }
      } else {
        if (this._moduleInstance !== undefined) {
          this._moduleInstance.enable();
        }
      }
    },
    toggleChanged: function() {
      this.toggleClass('toggle', this.toggle, this.$.uiCheckbox);
    },
    sliderChanged: function() {
      this.toggleClass('slider', this.slider, this.$.uiCheckbox);
    },
    ready: function() {
      if (this.toggle) {
        this.$.uiCheckbox.classList.add('toggle');
      }
      if (this.slider) {
        this.$.uiCheckbox.classList.add('slider');
      }
      var _self = this;
      var settings = {
        onChecked: function() {
          _self.value = true;
        },
        onUnchecked: function() {
          _self.value = false;
        }
      };

      // convert string values to bool
      if (this.value === "true") {
        this.value = true;
      }
      if (this.value === "false") {
        this.value = false;
      }

      if (this.value) {
        this.$.input.setAttribute('checked', 'true');
      }

      this._moduleInstance = new atFormCheckbox(this, settings);

      // set disabled if element is disabled
      if (this.disabled) {
        this._moduleInstance.disable();
      }

      this.valueChanged(this.value, this.value);
    }
  });

  (function(window, document, undefined) {
    "use strict";

    var module = window.atFormCheckbox = function(polymerElement, userSettings) {
      var settings = this.settings = util.extend(true, {}, atFormCheckbox.settings, userSettings);

      var className = this.className = settings.className;
      var namespace = settings.namespace;
      var selector = settings.selector;

      var eventNamespace = '.' + namespace;
      var moduleNamespace = 'module-' + namespace;

      var observer = this.observer;
      var element = this.element = polymerElement.$.uiCheckbox;

      var $module = this.$module = polymerElement.$.uiCheckbox;
      this.$label = $module.querySelector(selector.label);
      this.$input = $module.querySelector(selector.input);

      this.initialize();

      // end of the function
      return this;
    };

    module.prototype.initialize = function() {
      this.initObjects();

      this.add.events();

      if (this.is.checked()) {
        this.set.checked();
        if (this.settings.fireOnInit) {
          this.settings.onChecked.call(this.$input);
        }
      } else {
        this.remove.checked();
        if (this.settings.fireOnInit) {
          this.settings.onUnchecked.call(this.$input);
        }
      }
      this.observeChanges();
    };

    module.prototype.destroy = function() {
      this.remove.events();
    };

    module.prototype.refresh = function() {
      // this here is module instance; we need this to be the html element
      $module = element;
      $label = element.querySelector(selector.label);
      $input = element.querySelector(selector.input);
    };

    module.prototype.observeChanges = function() {
      if ('MutationObserver' in window) {
        this.observer = new MutationObserver(function(mutations) {
          this.refresh();
        });
        this.observer.observe(this.element, {
          childList: true,
          subtree: true
        });
      }
    };

    module.prototype.initObjects = function() {
      var _self = this;

      this.event = {
        keydown: function(event) {
          var
            key = event.which,
            keyCode = {
              enter: 13,
              space: 32,
              escape: 27
            },
            ex;
          if (key == keyCode.escape) {
            // using try catch here because there is bug in firefox:
            // see here: https://bugzilla.mozilla.org/show_bug.cgi?id=867418
            try {
              var blurEvent = document.createEvent('HTMLEvents');
              blurEvent.initEvent('blur', false, false);
              _self.$module.dispatchEvent(blurEvent);
            } catch (ex) {}
          }
          if (!event.ctrlKey && (key == keyCode.enter || key == keyCode.space)) {
            _self.toggle.call(this);
            event.preventDefault();
          }
        }
      }

      this.is = {
        radio: function() {
          return _self.$module.classList.contains(_self.className.radio);
        },
        checked: function() {
          var checkedAttr = _self.$input.getAttribute('checked');
          return (checkedAttr !== null || checkedAttr !== '') && checkedAttr;
        },
        unchecked: function() {
          return !_self.is.checked();
        }
      }

      this.can = {
        change: function() {
          var hasDisabled = _self.$module.classList.contains(_self.className.disabled);
          var hasReadonly = _self.$module.classList.contains(_self.className.readOnly);
          var hasPropDisabled = _self.$input.getAttribute('disabled');
          return !(hasDisabled || hasReadonly || hasPropDisabled);
        },
        uncheck: function() {
          return (typeof _self.settings.uncheckable === 'boolean') ? _self.settings.uncheckable : !_self.is.radio();
        }
      }

      this.set = {
        checked: function() {
          _self.$module.classList.add(_self.className.checked);
        },
        tab: function() {
          if (_self.$input.getAttribute('tabindex') === undefined) {
            _self.$input.setAttribute('tabindex', 0);
          }
        }
      }

      this.has = {
        label: function() {
          return (_self.$label.length > 0);
        }
      }

      this.add = {
        events: function() {
          _self.$module.addEventListener('click', _self.toggle);
          _self.$input.addEventListener('keydown', _self.event.keydown);
        }
      }

      this.remove = {
        checked: function() {
          _self.$module.classList.remove(_self.className.checked);
        },
        events: function() {
          _self.$module.removeEventListener('click', _self.toggle);
          _self.$input.removeEventListener('keydown', _self.event.keydown);
        }
      }

      this.toggle = function(event) {
        if (!_self.can.change()) {
          return;
        }
        if (_self.is.unchecked()) {
          _self.check();
        } else if (_self.is.checked() && _self.can.uncheck()) {
          _self.uncheck();
        }
      }

    }; // end of initObjects

    module.prototype.enable = function() {
      this.$module.classList.remove(this.className.disabled);
      this.$input.removeAttribute('disabled');
      this.settings.onEnabled.call(this.$input);
    };

    module.prototype.disable = function() {
      this.$module.classList.add(this.className.disabled);
      this.$input.setAttribute('disabled', true);
      this.settings.onDisabled.call(this.$input);
    };

    module.prototype.check = function() {
      var ex;
      this.$input.setAttribute('checked', 'true');

      // using try catch here because there is bug in firefox:
      // see here: https://bugzilla.mozilla.org/show_bug.cgi?id=867418
      try {
        var changeEvent = document.createEvent('HTMLEvents');
        changeEvent.initEvent('change', false, false);
        this.$input.dispatchEvent(changeEvent);
      } catch (ex) {}

      this.set.checked();

      // using try catch here because there is bug in firefox:
      // see here: https://bugzilla.mozilla.org/show_bug.cgi?id=867418
      try {
        var blurEvent = document.createEvent('HTMLEvents');
        blurEvent.initEvent('blur', false, false);
        this.$input.dispatchEvent(blurEvent);
      } catch (ex) {}

      this.settings.onChange.call(this.$input);
      this.settings.onChecked.call(this.$input);
    };

    module.prototype.uncheck = function() {
      var ex;
      this.$input.removeAttribute('checked');

      // using try catch here because there is bug in firefox:
      // see here: https://bugzilla.mozilla.org/show_bug.cgi?id=867418
      try {
        var changeEvent = document.createEvent('HTMLEvents');
        changeEvent.initEvent('change', false, false);
        this.$input.dispatchEvent(changeEvent);
      } catch (ex) {}

      this.remove.checked();

      // using try catch here because there is bug in firefox:
      // see here: https://bugzilla.mozilla.org/show_bug.cgi?id=867418
      try {
        var blurEvent = document.createEvent('HTMLEvents');
        blurEvent.initEvent('blur', false, false);
        this.$input.dispatchEvent(blurEvent);
      } catch (ex) {}

      this.settings.onChange.call(this.$input);
      this.settings.onUnchecked.call(this.$input);
    }

    // default settings for semantic checkbox
    window.atFormCheckbox.settings = {
      name: 'Checkbox',
      namespace: 'checkbox',

      // delegated event context
      uncheckable: 'auto',
      fireOnInit: true,

      onChange: function() {},
      onChecked: function() {},
      onUnchecked: function() {},
      onEnabled: function() {},
      onDisabled: function() {},

      className: {
        checked: 'checked',
        disabled: 'disabled',
        radio: 'radio',
        readOnly: 'read-only'
      },

      selector: {
        input: 'input[type="checkbox"], input[type="radio"]',
        label: 'label'
      }

    };

    var util = {};

    var class2type = {
      "[object Boolean]": "boolean",
      "[object Number]": "number",
      "[object String]": "string",
      "[object Function]": "function",
      "[object Array]": "array",
      "[object Date]": "date",
      "[object RegExp]": "regexp",
      "[object Object]": "object",
      "[object Error]": "error",
    };

    var hasOwn = class2type.hasOwnProperty;

    util.type = function(obj) {
      if (obj == null) {
        return obj + "";
      }
      // Support: Android<4.0, iOS<6 (functionish RegExp)
      return typeof obj === "object" || typeof obj === "function" ?
        class2type[Object.prototype.toString.call(obj)] || "object" :
        typeof obj;
    };

    util.isArray = function(obj) {
      return util.type(obj) == Array.isArray;
    };

    util.isWindow = function(obj) {
      return obj != null && obj === obj.window;
    };

    util.isPlainObject = function(obj) {
      // Not plain objects:
      // - Any object or value whose internal [[Class]] property is not "[object Object]"
      // - DOM nodes
      // - window
      if (util.type(obj) !== "object" || obj.nodeType || util.isWindow(obj)) {
        return false;
      }

      if (obj.constructor &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }

      // If the function hasn't returned already, we're confident that
      // |obj| is a plain object, created by {} or constructed with new Object
      return true;
    };

    util.isFunction = function(obj) {
      return util.type(obj) === "function";
    };

    // copy paste and rework of jQuery.extend function; I put it in atFormCheckbox namespace
    // use the same way as jQuery.extend
    util.extend = function() {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if (typeof target === "boolean") {
        deep = target;

        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if (typeof target !== "object" && !util.isFunction(target)) {
        target = {};
      }

      // Extend jQuery itself if only one argument is passed
      if (i === length) {
        target = this;
        i--;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name];

            // Prevent never-ending loop
            if (target === copy) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if (deep && copy && (util.isPlainObject(copy) || (copyIsArray = util.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && util.isArray(src) ? src : [];

              } else {
                clone = src && util.isPlainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[name] = util.extend(deep, clone, copy);

              // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    };

  })(window, document, undefined);
</script>
